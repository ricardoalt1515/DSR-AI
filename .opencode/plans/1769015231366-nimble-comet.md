# Plan Review: Delete/Archive/Purge Policy

## Final Verdict: ✅ APPROVED (with refinements)

Reviewed by: code-simplifier, libraryan, explore agents

---

## Summary

Original plan is solid. Author accepted all recommended refinements:

| Original | Refined |
|----------|---------|
| `is_archived` + `archived_at` | Only `archived_at` (NULL = active) |
| `archived_reason: str` | `archived_by_parent_id: UUID \| NULL` |
| `DELETE /x` → archive | `POST /x/archive`, `DELETE /x` = purge |
| 3 separate guards | Single `require_not_archived(entity)` |

---

## Approved Design

### Data Model

**No genérico — FK específico por tabla:**

```python
# Company: no tiene parent (siempre NULL o no incluir el campo)
class Company(Base):
    archived_at: datetime | None
    archived_by_user_id: UUID | None  # FK users

# Location: parent es Company
class Location(Base):
    archived_at: datetime | None
    archived_by_user_id: UUID | None  # FK users
    archived_by_parent_id: UUID | None  # FK companies, ON DELETE SET NULL

# Project: parent es Location
class Project(Base):
    archived_at: datetime | None
    archived_by_user_id: UUID | None  # FK users
    archived_by_parent_id: UUID | None  # FK locations, ON DELETE SET NULL
```

**Índices:**
- Filtrado: `(organization_id, archived_at)` — queries principales
- Partial unique: `WHERE archived_at IS NULL` — solo si hay uniques por nombre "solo activos"

### API Endpoints
```
POST   /companies/{id}/archive    → archive (cascade to children)
POST   /companies/{id}/restore    → restore (cascade where archived_by_parent_id matches)
DELETE /companies/{id}            → purge (requires archived_at IS NOT NULL)
```
Purge body: `{"confirm_name": "exact-entity-name"}` (server-side validation ✅ industry standard)

### Guard
```python
def require_not_archived[T: ArchivableMixin](entity: T) -> T:
    if entity.archived_at is not None:
        raise HTTPException(409, f"{type(entity).__name__} is archived")
    return entity
```

### Write Guards (not just AI)

**Check before persist en TODAS las rutas de escritura:**
- Files: upload, delete
- Proposals: generate, delete
- project_data mutations
- Contacts: create, update, delete

```python
async def persist_anything_to_project(project_id: UUID, ...):
    project = await get_project(project_id)
    if project.archived_at:
        raise HTTPException(409, "Project is archived")
    # ... persist ...
```

**AI jobs específicamente:** doble check (before work + before persist) + heartbeat para jobs largos.

---

## Migration Plan

1. New migration:
   - Add `archived_at`, `archived_by_user_id` to Company
   - Add `archived_at`, `archived_by_user_id`, `archived_by_parent_id` (FK companies) to Location
   - Add `archived_by_user_id`, `archived_by_parent_id` (FK locations) to Project
   - Drop `is_archived` from Project (existing migration added it)
   - Index: `(organization_id, archived_at)` en cada tabla

2. Update ORM models to match

### Purge Storage Cleanup (crítico)

Purge debe borrar artifacts físicos:
```python
async def purge_project(project_id):
    # 1. Collect storage keys BEFORE delete
    files = await get_project_files(project_id)  # file_path
    proposals = await get_proposals(project_id)  # pdf_path + ai_metadata.pdfPaths
    
    # 2. Hard delete DB (cascade)
    await db.delete(project)
    await db.commit()
    
    # 3. Delete storage (best-effort, log failures)
    for f in files:
        await storage.delete(f.file_path)
    for p in proposals:
        await storage.delete(p.pdf_path)
        for extra in p.ai_metadata.get("pdfPaths", []):
            await storage.delete(extra)
```

Igual para Location (cascade a projects) y Company (cascade a locations→projects).

### Cascade Restore (recursivo)

```python
async def restore_company(company_id):
    company.archived_at = None
    # Restore locations archived by this company
    locations = await get_locations(archived_by_parent_id=company_id)
    for loc in locations:
        await restore_location(loc.id)  # recursively restores projects
```

---

## Remaining Questions (non-blocking)

1. Archived in search/autocomplete? (Plan says exclude; confirm this is desired)
2. If location moved while archived, which parent_id on restore? (Edge case, handle when it arises)
